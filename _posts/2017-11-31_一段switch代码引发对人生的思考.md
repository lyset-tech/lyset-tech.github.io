---
layout:     post
title:      "2017-11-29_01_你所不知道的Java之Switch"
subtitle:   "一些Java编程的常识"
date:       2017-11-29
author:     "雷塞特"
header-img: "img/header-banner/coffee-bean_1920x1280.jpg"
catalog: true
tags:
    - java
---

# switch long
  作为一个java新手在学习java的过程中，机缘巧合的我写了一段这样的代码
  
    Long l = 0L;
    
    switch (l){
        。。。。

  于是我得到了这个的错误：
  
      T.java:5: error: incompatible types: Long cannot be converted to int
             switch (l){  
             
  什么鬼，啥情况，赶紧百度百度
  
  官方是这样说的
    
     switch works with the byte, short, char, and int primitive data types.
     It also works with enumerated types (discussed in Enum Types), the String class, 
     and a few special classes that wrap certain primitive types: 
     Character, Byte, Short, and Integer .
     
？？？only

？？byte？short？？char？？and？int？

？？？Enum？String？Character？？Byte？？Short？？and？Integer？
     
嗯？为什么没有long？接着百度

从官网上找到[Compile Switch](https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-3.html#jvms-3.10)这一节 

偏好中文读者点击这里[Java虚拟机规范（Java SE 7）](http://vdisk.weibo.com/s/zvvfOIan7YyZw)

官网里面的描述是这样的：
    
    Compilation of switch statements uses the tableswitch and lookupswitch instructions. 
    The tableswitch instruction is used when the cases of the switch can be efficiently represented as indices into a table of target offsets. 
    The default target of the switch is used if the value of the expression of the switch falls outside the range of valid indices. For instance:
    
## tableswitch ? lookupswitch ? 

    编译switch 使用两种指令 tableswitch 和 lookupswitch
    当switch内的case值能被表示为一个表中的索引值时，则使用tableswitch。

接着看

    The Java Virtual Machine's tableswitch and lookupswitch instructions operate only on int data. Because operations on byte, char, or short values are internally promoted to int, a switch whose expression evaluates to one of those types is compiled as though it evaluated to type int. 

好像说到我们的疑问了，

    tableswitch 和lookupswitch只操作在int数据上，对于byte char short的操作在内部都会提升为int

原来JVM底层提供两种只支持2*32大小的偏移量（也就是int的大小）的switch指令 tableswitch  和 lookupswitch 。
所以在java中其实也只实现了byte, short, char, and int的switch，至于他们的包装类型以及Enum，String都是编译器给我们的语法糖,甚至于byte，short，char也会在运行时提升为int。
   
## 居然都是语法糖！

### 先看看原始类型的包装类是如何实现switch的
先瞅一眼源码：
``` java
private void integerSwitch()
   Integer integerS = 0;
   switch (integerS){
      case 1:
      case 0:
      case 2:
        System.out.println(integerS);
   }
}
A μ
```
使用[jad](http://www.javadecompilers.com/) 反编译后：

``` java
private void integerSwitch()
{
    Integer integer = Integer.valueOf(0);
    switch(integer.intValue())
    {
    case 0: // '\0'
    case 1: // '\001'
    case 2: // '\002'
        System.out.println(integer);
        break;
    }
}
```
嗯，果然真的，使用intValue()解包，

等下，怎么顺序感觉怪怪的，说好的102，居然给我排了队，

还是用JDK自带的javap，看一眼bytecode吧

bytecode：
``` java
    0: iconst_0
    1: invokestatic  #2                  // Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;
    4: astore_1
    5: aload_1
    6: invokevirtual #3                  // Method java/lang/Integer.intValue:()I
    9: tableswitch   { // 0 to 2
                   0: 36
                   1: 36
                   2: 36
             default: 43
        }
    36: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;
    39: aload_1
    40: invokevirtual #5                  // Method java/io/PrintStream.println:(Ljava/lang/Object;)V
    43: return
```
嗯，jad还是可信的。

明白了，前面提到了对于连续case值会使用tableswitch，编译器为我们调整了顺序（干得漂亮）。

### 好接下来是 String 类型的 switch
源码：
``` java
    private void test1(){
	String feiniao = "feiniao";
        switch(feiniao){
            case "FB":
                System.out.println("FB");
                break;
            case "Ea":
                System.out.println("Ea");
                break;
        }
    }
```
使用[jad](http://www.javadecompilers.com/) 反编译后：
``` java
private void test1()
    {
        String s = "feiniao";
        String s1 = s;
        byte byte0 = -1;
        switch(s1.hashCode())
        {
        case 2236:
            if(s1.equals("Ea"))
                byte0 = 1;
            else
            if(s1.equals("FB"))
                byte0 = 0;
            break;
        }
        switch(byte0)
        {
        case 0: // '\0'
            System.out.println("FB");
            break;

        case 1: // '\001'
            System.out.println("Ea");
            break;
        }
    }
```
这糖可真甜那！

先来看看这个使用了新的变量s1，防止并发操作修改所造成的结果不可知。
使用了一个byte的变量和两次的switch，防止了[hash碰撞](https://zacard.net/2016/08/29/hash-collision/)
### 最后是 Enum 的switch 
源码：
```java
enum Em {
    A,B,C,D,E;
}
private void test2(){
       Em em = Em.A;
       switch (em){
            case A:
                 System.out.println("A");
                 break;
            case C:
                 System.out.println("C");
                 break;
            case E:
    		     System.out.println("E");
                 break;
          default:
        
       }
    }
```   
使用[jad](http://www.javadecompilers.com/) 反编译后：
```java
private void test2()
    {
        Em em = Em.A;
        static class _cls1
        {

            static final int $SwitchMap$Em[];

            static
            {
                $SwitchMap$Em = new int[Em.values().length];
                try
                {
                    $SwitchMap$Em[Em.A.ordinal()] = 1;
                }
                catch(NoSuchFieldError nosuchfielderror) { }
                try
                {
                    $SwitchMap$Em[Em.C.ordinal()] = 2;
                }
                catch(NoSuchFieldError nosuchfielderror1) { }
                try
                {
                    $SwitchMap$Em[Em.E.ordinal()] = 3;
                }
                catch(NoSuchFieldError nosuchfielderror2) { }
            }
        }

        switch(_cls1.SwitchMap.Em[em.ordinal()])
        {
        case 1: // '\001'
            System.out.println("A");
            break;

        case 2: // '\002'
            System.out.println("C");
            break;

        case 3: // '\003'
            System.out.println("E");
            break;
        }
    }
```   

信息量有点大

- 首先方法内多了一个类，

- 然后目录里多了一个名 T$1的类，

- switch的东西也不是原先的我们定义的Em，

让我缓缓，，，先用javap看一下bytecode

```java
         0: getstatic     #9                  // Field Em.A:LEm;
         3: astore_1
         4: getstatic     #10                 // Field T$1.$SwitchMap$Em:[I
         7: aload_1
         8: invokevirtual #11                 // Method Em.ordinal:()I
        11: iaload
        12: tableswitch   { // 1 to 3
                       1: 40
                       2: 51
                       3: 62
                 default: 73
            }
     。。。
     。。。
        70: goto          73
        73: return
```   
并没有_cls1这个类，不过可以看到一个静态常量T$1.$SwitchMap$Em，让我们看一下目录里的T$1.class长啥样
```java
static class T$1
{

    static final int $SwitchMap$Em[];

    static
    {
        $SwitchMap$Em = new int[Em.values().length];
        try
        {
            $SwitchMap$Em[Em.A.ordinal()] = 1;
        }
        catch(NoSuchFieldError nosuchfielderror) { }
        try
        {
            $SwitchMap$Em[Em.C.ordinal()] = 2;
        }
        catch(NoSuchFieldError nosuchfielderror1) { }
        try
        {
            $SwitchMap$Em[Em.E.ordinal()] = 3;
        }
        catch(NoSuchFieldError nosuchfielderror2) { }
    }
}
```
好像明白了什么！
- 假如不使用这个额外的类，我所想象的代码因该长这样
``` java
    0: getstatic     #9  ／／偷个懒不管常量池里的东西
    3: invokevirtual #11                 // Method Em.ordinal:()I
    6: iaload
    7: lookupswitch   { // 1 to 3
                1: 40
                3: 51
                5: 62
            default: 73
    }
    。。。
    。。。
```
当使用了临时类T$1后可以将lookupswitch优化为tableswitch。

嗯，编译器真是辛苦您了，您做了这么多优化，我又想问一句了到底能快多少

（糟糕的反编译工具我们就不去管它了）

## tableswitch 能比 lookupswitch 快多少呢？
接着往下看
    
    Where the cases of the switch are sparse, the table representation of the tableswitch instruction becomes inefficient in terms of space. The lookupswitch instruction may be used instead. The lookupswitch instruction pairs int keys (the values of the case labels) with target offsets in a table. When a lookupswitch instruction is executed, the value of the expression of the switch is compared against the keys in the table. If one of the keys matches the value of the expression, execution continues at the associated target offset. If no key matches, execution continues at the default target.

   

当switch里的case值非常稀疏的时候，tableswitch的做法在空间使用方面非常低效，有道理！，所以lookupswitch 将case的int值和转跳的偏移量作为一对放在了一个表里，当lookupswitch被执行的时候，这switch的表达式的值和这个表里的keys逐一比较，没有找到则使用默认值。
嗯，大概明白了对于一些连续的case值jvm会使用tableswitch，教为稀疏的case值则使用lookupswitch。
 
## 那么让我们再看看jit是怎么做的
